{
  "problemId": "p16",
  "title": "String Anagrams",
  "description": "Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase.",
  "aim": "The goal is to understand how to use sliding window to find all starting positions of anagram patterns in a string.",
  "moduleId": "slidingWindow",
  "submoduleId": "sw_advanced",
  "difficulty": "Medium",
  "tags": ["String", "Sliding Window", "Anagram", "Hash Map", "Pattern Matching"],
  "examples": [
    {
      "input": "s = \"cbaebabacd\", p = \"abc\"",
      "output": "[0, 6]",
      "explanation": "The substring with start index = 0 is \"cba\", which is an anagram of \"abc\". The substring with start index = 6 is \"bac\", which is an anagram of \"abc\"."
    },
    {
      "input": "s = \"abab\", p = \"ab\"",
      "output": "[0, 1, 2]",
      "explanation": "The substring with start index = 0 is \"ab\", which is an anagram of \"ab\". The substring with start index = 1 is \"ba\", which is an anagram of \"ab\". The substring with start index = 2 is \"ab\"."
    }
  ],
  "playground": {
    "initialState": {
      "stringElements": [
        {"value": "c", "state": "not_yet_reached", "index": 0},
        {"value": "b", "state": "not_yet_reached", "index": 1},
        {"value": "a", "state": "not_yet_reached", "index": 2},
        {"value": "e", "state": "not_yet_reached", "index": 3},
        {"value": "b", "state": "not_yet_reached", "index": 4},
        {"value": "a", "state": "not_yet_reached", "index": 5},
        {"value": "b", "state": "not_yet_reached", "index": 6},
        {"value": "a", "state": "not_yet_reached", "index": 7},
        {"value": "c", "state": "not_yet_reached", "index": 8},
        {"value": "d", "state": "not_yet_reached", "index": 9}
      ],
      "pattern": "abc",
      "patternFreq": {"a": 1, "b": 1, "c": 1},
      "windowFreq": {},
      "matches": 0,
      "requiredMatches": 3,
      "windowStart": 0,
      "windowEnd": 0,
      "currentLength": 0,
      "result": []
    },
    "steps": [
      {
        "stepId": 1,
        "description": "Initialize variables. Set windowStart = 0, matches = 0, windowFreq = {}, requiredMatches = 3, result = []",
        "expectedAction": "click_initialize",
        "uiState": {
          "stringElements": [
            {"value": "c", "state": "not_yet_reached", "index": 0},
            {"value": "b", "state": "not_yet_reached", "index": 1},
            {"value": "a", "state": "not_yet_reached", "index": 2},
            {"value": "e", "state": "not_yet_reached", "index": 3},
            {"value": "b", "state": "not_yet_reached", "index": 4},
            {"value": "a", "state": "not_yet_reached", "index": 5},
            {"value": "b", "state": "not_yet_reached", "index": 6},
            {"value": "a", "state": "not_yet_reached", "index": 7},
            {"value": "c", "state": "not_yet_reached", "index": 8},
            {"value": "d", "state": "not_yet_reached", "index": 9}
          ],
          "pattern": "abc",
          "patternFreq": {"a": 1, "b": 1, "c": 1},
          "windowFreq": {},
          "matches": 0,
          "requiredMatches": 3,
          "windowStart": 0,
          "windowEnd": 0,
          "currentLength": 0,
          "result": [],
          "highlightedElements": []
        },
        "jarvisMessage": "Welcome! Let's solve this anagram finding problem. We need to find all starting indices where an anagram of pattern p appears in string s. We'll use a sliding window with character frequency tracking.",
        "codeHint": "// Initialize variables\nlet windowStart = 0;\nlet matches = 0;\nlet windowFreq = {};\nlet requiredMatches = pattern.length;\nlet result = [];",
        "codeBotMessage": "Hey! I'm CodeBot. This is similar to the permutation problem, but now we need to find ALL occurrences and return their starting indices. The key is maintaining a fixed-size window and tracking when we have a perfect frequency match!",
        "codeSnippet": "let windowStart = 0;        // Start of current window\nlet matches = 0;            // Characters that match pattern frequency\nlet windowFreq = {};        // Frequency map for current window\nlet requiredMatches = 3;    // We need 3 characters to match\nlet result = [];            // Store starting indices of anagrams"
      },
      {
        "stepId": 2,
        "description": "Expand window to include first character 'c'. Update windowFreq['c'] = 1. Check if 'c' frequency matches pattern: yes! Update matches = 1",
        "expectedAction": "expand_window",
        "expectedElementIndex": 0,
        "uiState": {
          "stringElements": [
            {"value": "c", "state": "in_window", "index": 0},
            {"value": "b", "state": "not_yet_reached", "index": 1},
            {"value": "a", "state": "not_yet_reached", "index": 2},
            {"value": "e", "state": "not_yet_reached", "index": 3},
            {"value": "b", "state": "not_yet_reached", "index": 4},
            {"value": "a", "state": "not_yet_reached", "index": 5},
            {"value": "b", "state": "not_yet_reached", "index": 6},
            {"value": "a", "state": "not_yet_reached", "index": 7},
            {"value": "c", "state": "not_yet_reached", "index": 8},
            {"value": "d", "state": "not_yet_reached", "index": 9}
          ],
          "pattern": "abc",
          "patternFreq": {"a": 1, "b": 1, "c": 1},
          "windowFreq": {"c": 1},
          "matches": 1,
          "requiredMatches": 3,
          "windowStart": 0,
          "windowEnd": 0,
          "currentLength": 1,
          "result": [],
          "highlightedElements": [0]
        },
        "jarvisMessage": "Great! We've added 'c' to our window. Since 'c' appears exactly once in our pattern \"abc\", and we have exactly one 'c' in our window, matches = 1. Our window length is 1, but we need 3 to match the pattern length.",
        "codeHint": "// Add current character to window frequency\nwindowFreq[s[windowEnd]] = (windowFreq[s[windowEnd]] || 0) + 1;\n// Check if this character frequency now matches pattern requirement"
      },
      {
        "stepId": 3,
        "description": "Expand window to include 'b'. Update windowFreq['b'] = 1. Check if 'b' frequency matches pattern: yes! Update matches = 2",
        "expectedAction": "expand_window",
        "expectedElementIndex": 1,
        "uiState": {
          "stringElements": [
            {"value": "c", "state": "in_window", "index": 0},
            {"value": "b", "state": "in_window", "index": 1},
            {"value": "a", "state": "not_yet_reached", "index": 2},
            {"value": "e", "state": "not_yet_reached", "index": 3},
            {"value": "b", "state": "not_yet_reached", "index": 4},
            {"value": "a", "state": "not_yet_reached", "index": 5},
            {"value": "b", "state": "not_yet_reached", "index": 6},
            {"value": "a", "state": "not_yet_reached", "index": 7},
            {"value": "c", "state": "not_yet_reached", "index": 8},
            {"value": "d", "state": "not_yet_reached", "index": 9}
          ],
          "pattern": "abc",
          "patternFreq": {"a": 1, "b": 1, "c": 1},
          "windowFreq": {"c": 1, "b": 1},
          "matches": 2,
          "requiredMatches": 3,
          "windowStart": 0,
          "windowEnd": 1,
          "currentLength": 2,
          "result": [],
          "highlightedElements": [0, 1]
        },
        "jarvisMessage": "Excellent! Now we have \"cb\" in our window. Since 'b' appears exactly once in our pattern \"abc\", and we have exactly one 'b' in our window, matches = 2. We're getting closer!",
        "codeHint": "// Move window end pointer and update frequencies\nwindowEnd++;\n// Check if new character contributes to match count"
      },
      {
        "stepId": 4,
        "description": "Expand window to include 'a'. Update windowFreq['a'] = 1. Check if 'a' frequency matches pattern: yes! Update matches = 3. Window length = 3, matches = 3. Check if window is anagram: yes! Add index 0 to result",
        "expectedAction": "expand_window",
        "expectedElementIndex": 2,
        "uiState": {
          "stringElements": [
            {"value": "c", "state": "in_window", "index": 0},
            {"value": "b", "state": "in_window", "index": 1},
            {"value": "a", "state": "in_window", "index": 2},
            {"value": "e", "state": "not_yet_reached", "index": 3},
            {"value": "b", "state": "not_yet_reached", "index": 4},
            {"value": "a", "state": "not_yet_reached", "index": 5},
            {"value": "b", "state": "not_yet_reached", "index": 6},
            {"value": "a", "state": "not_yet_reached", "index": 7},
            {"value": "c", "state": "not_yet_reached", "index": 8},
            {"value": "d", "state": "not_yet_reached", "index": 9}
          ],
          "pattern": "abc",
          "patternFreq": {"a": 1, "b": 1, "c": 1},
          "windowFreq": {"c": 1, "b": 1, "a": 1},
          "matches": 3,
          "requiredMatches": 3,
          "windowStart": 0,
          "windowEnd": 2,
          "currentLength": 3,
          "result": [0],
          "highlightedElements": [0, 1, 2]
        },
        "jarvisMessage": "ðŸŽ‰ Fantastic! We've found our first anagram! The window \"cba\" has length 3 and matches = 3. Since all character frequencies match exactly, \"cba\" is an anagram of \"abc\". We add index 0 to our result array.",
        "codeHint": "// Check if we have found an anagram\nif (matches === requiredMatches) {\n  // Add starting index to result\n  result.push(windowStart);\n}"
      },
      {
        "stepId": 5,
        "description": "Slide window by removing 'c' and adding 'e'. Update windowFreq: remove 'c', add 'e'. Since 'c' was contributing to matches, decrement matches = 2. 'e' not in pattern, no change to matches",
        "expectedAction": "slide_window",
        "expectedElementIndex": 3,
        "uiState": {
          "stringElements": [
            {"value": "c", "state": "out_of_window_past", "index": 0},
            {"value": "b", "state": "in_window", "index": 1},
            {"value": "a", "state": "in_window", "index": 2},
            {"value": "e", "state": "in_window", "index": 3},
            {"value": "b", "state": "not_yet_reached", "index": 4},
            {"value": "a", "state": "not_yet_reached", "index": 5},
            {"value": "b", "state": "not_yet_reached", "index": 6},
            {"value": "a", "state": "not_yet_reached", "index": 7},
            {"value": "c", "state": "not_yet_reached", "index": 8},
            {"value": "d", "state": "not_yet_reached", "index": 9}
          ],
          "pattern": "abc",
          "patternFreq": {"a": 1, "b": 1, "c": 1},
          "windowFreq": {"b": 1, "a": 1, "e": 1},
          "matches": 2,
          "requiredMatches": 3,
          "windowStart": 1,
          "windowEnd": 3,
          "currentLength": 3,
          "result": [0],
          "highlightedElements": [1, 2, 3]
        },
        "jarvisMessage": "Now we've slid the window to \"bae\". Since we removed 'c' (which was contributing to our match count), matches decreased to 2. 'e' is not in our pattern, so it doesn't affect matches. We need to find more anagrams!",
        "codeHint": "// Slide window by removing leftmost and adding rightmost\nwindowFreq[s[windowStart]]--;\n// If removed character was contributing to matches, decrement matches\nif (patternFreq[s[windowStart]] && windowFreq[s[windowStart]] < patternFreq[s[windowStart]]) {\n  matches--;\n}\nwindowStart++;"
      },
      {
        "stepId": 6,
        "description": "Continue sliding window. Remove 'b', add 'b'. Update windowFreq: 'b' count becomes 2. Since 'b' frequency now exceeds pattern requirement, matches stays 2",
        "expectedAction": "slide_window",
        "expectedElementIndex": 4,
        "uiState": {
          "stringElements": [
            {"value": "c", "state": "out_of_window_past", "index": 0},
            {"value": "b", "state": "out_of_window_past", "index": 1},
            {"value": "a", "state": "in_window", "index": 2},
            {"value": "e", "state": "in_window", "index": 3},
            {"value": "b", "state": "in_window", "index": 4},
            {"value": "a", "state": "not_yet_reached", "index": 5},
            {"value": "b", "state": "not_yet_reached", "index": 6},
            {"value": "a", "state": "not_yet_reached", "index": 7},
            {"value": "c", "state": "not_yet_reached", "index": 8},
            {"value": "d", "state": "not_yet_reached", "index": 9}
          ],
          "pattern": "abc",
          "patternFreq": {"a": 1, "b": 1, "c": 1},
          "windowFreq": {"a": 1, "e": 1, "b": 1},
          "matches": 2,
          "requiredMatches": 3,
          "windowStart": 2,
          "windowEnd": 4,
          "currentLength": 3,
          "result": [0],
          "highlightedElements": [2, 3, 4]
        },
        "jarvisMessage": "We've slid to \"aeb\". The 'b' count is now 1, which matches our pattern requirement, so matches = 2. We still need one more character to match to find another anagram.",
        "codeHint": "// Continue sliding and updating frequencies\n// Track when character frequencies match pattern requirements exactly"
      },
      {
        "stepId": 7,
        "description": "Slide window to \"eba\". Remove 'a', add 'a'. Update windowFreq: 'a' count becomes 1. Check if 'a' frequency matches pattern: yes! Update matches = 3. Found another anagram! Add index 2 to result",
        "expectedAction": "slide_window",
        "expectedElementIndex": 5,
        "uiState": {
          "stringElements": [
            {"value": "c", "state": "out_of_window_past", "index": 0},
            {"value": "b", "state": "out_of_window_past", "index": 1},
            {"value": "a", "state": "out_of_window_past", "index": 2},
            {"value": "e", "state": "in_window", "index": 3},
            {"value": "b", "state": "in_window", "index": 4},
            {"value": "a", "state": "in_window", "index": 5},
            {"value": "b", "state": "not_yet_reached", "index": 6},
            {"value": "a", "state": "not_yet_reached", "index": 7},
            {"value": "c", "state": "not_yet_reached", "index": 8},
            {"value": "d", "state": "not_yet_reached", "index": 9}
          ],
          "pattern": "abc",
          "patternFreq": {"a": 1, "b": 1, "c": 1},
          "windowFreq": {"e": 1, "b": 1, "a": 1},
          "matches": 3,
          "requiredMatches": 3,
          "windowStart": 3,
          "windowEnd": 5,
          "currentLength": 3,
          "result": [0, 2],
          "highlightedElements": [3, 4, 5]
        },
        "jarvisMessage": "ðŸŽ‰ Excellent! We've found another anagram! The window \"eba\" has length 3 and matches = 3. Since all character frequencies match exactly, \"eba\" is an anagram of \"abc\". We add index 2 to our result array.",
        "codeHint": "// Another anagram found!\n// Add starting index to result\nresult.push(windowStart);"
      },
      {
        "stepId": 8,
        "description": "Continue sliding window through remaining characters. No more anagrams found. Final result = [0, 2]",
        "expectedAction": "slide_window",
        "expectedElementIndex": 6,
        "uiState": {
          "stringElements": [
            {"value": "c", "state": "out_of_window_past", "index": 0},
            {"value": "b", "state": "out_of_window_past", "index": 1},
            {"value": "a", "state": "out_of_window_past", "index": 2},
            {"value": "e", "state": "out_of_window_past", "index": 3},
            {"value": "b", "state": "in_window", "index": 4},
            {"value": "a", "state": "in_window", "index": 5},
            {"value": "b", "state": "in_window", "index": 6},
            {"value": "a", "state": "not_yet_reached", "index": 7},
            {"value": "c", "state": "not_yet_reached", "index": 8},
            {"value": "d", "state": "not_yet_reached", "index": 9}
          ],
          "pattern": "abc",
          "patternFreq": {"a": 1, "b": 1, "c": 1},
          "windowFreq": {"b": 2, "a": 1},
          "matches": 2,
          "requiredMatches": 3,
          "windowStart": 4,
          "windowEnd": 6,
          "currentLength": 3,
          "result": [0, 2],
          "highlightedElements": [4, 5, 6]
        },
        "jarvisMessage": "We've slid to \"bab\". The 'b' count is 2, which exceeds our pattern requirement of 1, so matches = 2. We continue sliding to find more potential anagrams.",
        "codeHint": "// Continue sliding and checking for anagrams\n// Track all starting indices where anagrams occur"
      },
      {
        "stepId": 9,
        "description": "Algorithm completed! We found 2 anagrams of \"abc\" in \"cbaebabacd\": at index 0 (\"cba\") and index 2 (\"eba\"). Final result = [0, 2]",
        "expectedAction": "complete_algorithm",
        "expectedElementIndex": 9,
        "uiState": {
          "stringElements": [
            {"value": "c", "state": "out_of_window_past", "index": 0},
            {"value": "b", "state": "out_of_window_past", "index": 1},
            {"value": "a", "state": "out_of_window_past", "index": 2},
            {"value": "e", "state": "out_of_window_past", "index": 3},
            {"value": "b", "state": "out_of_window_past", "index": 4},
            {"value": "a", "state": "out_of_window_past", "index": 5},
            {"value": "b", "state": "out_of_window_past", "index": 6},
            {"value": "a", "state": "out_of_window_past", "index": 7},
            {"value": "c", "state": "out_of_window_past", "index": 8},
            {"value": "d", "state": "out_of_window_past", "index": 9}
          ],
          "pattern": "abc",
          "patternFreq": {"a": 1, "b": 1, "c": 1},
          "windowFreq": {"a": 1, "c": 1, "d": 1},
          "matches": 2,
          "requiredMatches": 3,
          "windowStart": 7,
          "windowEnd": 9,
          "currentLength": 3,
          "result": [0, 2],
          "highlightedElements": [7, 8, 9]
        },
        "jarvisMessage": "ðŸŽ‰ Congratulations! You've successfully completed the anagram finding algorithm. We found 2 anagrams of \"abc\" in the string: at index 0 (\"cba\") and index 2 (\"eba\").",
        "codeHint": "// Return the final result\nreturn result; // Returns [0, 2]",
        "codeBotMessage": "Fantastic! You've mastered this advanced sliding window problem. The key insight was maintaining a fixed-size window and tracking character frequencies to detect when we have perfect anagram matches. This gives us O(n) time complexity!",
        "codeSnippet": "// Algorithm completed!\n// Found 2 anagrams: \"cba\" at index 0, \"eba\" at index 2\n// Final result: [0, 2]\nreturn result; // Returns [0, 2]"
      }
    ],
    "jarvisConfig": {
      "personality": "encouraging",
      "hintLevels": ["subtle", "helpful", "explicit"],
      "motivationalMessages": [
        "Great thinking! You're understanding the anagram finding concept.",
        "That's exactly right! You're seeing how to track all anagram occurrences.",
        "Excellent intuition! You're mastering the frequency matching logic.",
        "You've got this! Each step brings you closer to mastering advanced sliding window."
      ]
    }
  },
  "solution": {
    "bruteForce": {
      "idea": "Generate all possible substrings of length p.length and check if each is an anagram of p.",
      "timeComplexity": "O(n * p.length)",
      "spaceComplexity": "O(p.length)",
      "walkthrough": [
        "Generate all substrings of length p.length.",
        "For each substring, check if it's an anagram of p.",
        "Store starting indices of matching anagrams.",
        "Return array of starting indices."
      ]
    },
    "optimal": {
      "idea": "Use sliding window with character frequency tracking. Maintain a window of size p.length and track when character frequencies match exactly.",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "walkthrough": [
        "Create frequency map for pattern p.",
        "Initialize sliding window of size p.length.",
        "Track character frequencies in current window.",
        "Count matches when frequencies match pattern requirements.",
        "Slide window and update frequencies.",
        "Add starting index to result when matches equals required matches.",
        "Return array of all starting indices."
      ]
    }
  },
  "code": {
    "javascript": "function findAnagrams(s, p) {\n    if (s.length < p.length) return [];\n    \n    const patternFreq = {};\n    const windowFreq = {};\n    \n    // Create frequency map for pattern\n    for (let char of p) {\n        patternFreq[char] = (patternFreq[char] || 0) + 1;\n    }\n    \n    let windowStart = 0;\n    let matches = 0;\n    const requiredMatches = Object.keys(patternFreq).length;\n    const result = [];\n    \n    for (let windowEnd = 0; windowEnd < s.length; windowEnd++) {\n        const rightChar = s[windowEnd];\n        \n        // Add right character to window\n        if (patternFreq[rightChar]) {\n            windowFreq[rightChar] = (windowFreq[rightChar] || 0) + 1;\n            if (windowFreq[rightChar] === patternFreq[rightChar]) {\n                matches++;\n            }\n        }\n        \n        // Contract window if it exceeds pattern length\n        if (windowEnd - windowStart + 1 > p.length) {\n            const leftChar = s[windowStart];\n            if (patternFreq[leftChar]) {\n                if (windowFreq[leftChar] === patternFreq[leftChar]) {\n                    matches--;\n                }\n                windowFreq[leftChar]--;\n            }\n            windowStart++;\n        }\n        \n        // Check if we found an anagram\n        if (matches === requiredMatches) {\n            result.push(windowStart);\n        }\n    }\n    \n    return result;\n}"
  }
}
