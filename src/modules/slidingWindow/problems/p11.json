{
  "problemId": "p11",
  "title": "Words Concatenation",
  "description": "Given a string and an array of words of equal length, find all starting indices where a concatenation of all words appears as a substring.",
  "aim": "Master the technique of using sliding window with fixed chunking and hashmap for complex pattern matching.",
  "moduleId": "slidingWindow",
  "submoduleId": "sw_advanced",
  "difficulty": "Hard",
  "tags": ["sliding-window", "hashmap", "string", "chunking", "advanced"],
  "examples": [
    {
      "input": "s = \"barfoothefoobarman\", words = [\"foo\", \"bar\"]",
      "output": "[0, 9]",
      "explanation": "The substring starting at index 0 is \"barfoo\". It is a concatenation of [\"bar\", \"foo\"] which is a permutation of words. The substring starting at index 9 is \"foobar\". It is a concatenation of [\"foo\", \"bar\"] which is a permutation of words."
    },
    {
      "input": "s = \"wordgoodgoodgoodbestword\", words = [\"word\", \"good\", \"best\", \"good\"]",
      "output": "[]",
      "explanation": "No valid concatenation exists."
    }
  ],
  "playground": {
    "initialState": {
      "string": "barfoothefoobarman",
      "words": ["foo", "bar"],
      "windowSize": 6,
      "wordLength": 3,
      "wordCount": 2
    },
    "visualization": {
      "type": "string_chunking",
      "showWordBoundaries": true,
      "showHashMap": true,
      "showWindow": true
    }
  },
  "solution": {
    "approach": "Fixed window with word-level sliding and hashmap frequency matching",
    "timeComplexity": "O(n * m)",
    "spaceComplexity": "O(m)",
    "keyInsight": "Use fixed window size (total word length) and slide word by word, maintaining frequency maps"
  },
  "code": {
    "template": "vector<int> findSubstring(string s, vector<string>& words) {\n    // Your code here\n}",
    "solution": "vector<int> findSubstring(string s, vector<string>& words) {\n    if (s.empty() || words.empty()) return {};\n    \n    int wordLen = words[0].length();\n    int wordCount = words.size();\n    int totalLen = wordLen * wordCount;\n    \n    unordered_map<string, int> wordMap;\n    for (const string& word : words) {\n        wordMap[word]++;\n    }\n    \n    vector<int> result;\n    \n    for (int i = 0; i < wordLen; i++) {\n        int left = i;\n        unordered_map<string, int> windowMap;\n        int count = 0;\n        \n        for (int right = i; right <= s.length() - wordLen; right += wordLen) {\n            string word = s.substr(right, wordLen);\n            \n            if (wordMap.find(word) != wordMap.end()) {\n                windowMap[word]++;\n                count++;\n                \n                while (windowMap[word] > wordMap[word]) {\n                    string leftWord = s.substr(left, wordLen);\n                    windowMap[leftWord]--;\n                    count--;\n                    left += wordLen;\n                }\n                \n                if (count == wordCount) {\n                    result.push_back(left);\n                }\n            } else {\n                windowMap.clear();\n                count = 0;\n                left = right + wordLen;\n            }\n        }\n    }\n    \n    return result;\n}"
  }
}
