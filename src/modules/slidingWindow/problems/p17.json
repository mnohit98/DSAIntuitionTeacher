{
  "problemId": "p17",
  "title": "Smallest Window Containing Substring",
  "description": "Given two strings s and t, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".",
  "aim": "The goal is to understand how to use sliding window to find the minimum window containing all characters of a target pattern.",
  "moduleId": "slidingWindow",
  "submoduleId": "sw_advanced",
  "difficulty": "Hard",
  "tags": ["String", "Sliding Window", "Minimum Window", "Hash Map", "Pattern Matching"],
  "examples": [
    {
      "input": "s = \"ADOBECODEBANC\", t = \"ABC\"",
      "output": "\"BANC\"",
      "explanation": "The minimum window substring \"BANC\" contains all characters from t: 'A', 'B', and 'C'."
    },
    {
      "input": "s = \"a\", t = \"a\"",
      "output": "\"a\"",
      "explanation": "The minimum window substring \"a\" contains the single character 'a' from t."
    }
  ],
  "playground": {
    "initialState": {
      "stringElements": [
        {"value": "A", "state": "not_yet_reached", "index": 0},
        {"value": "D", "state": "not_yet_reached", "index": 1},
        {"value": "O", "state": "not_yet_reached", "index": 2},
        {"value": "B", "state": "not_yet_reached", "index": 3},
        {"value": "E", "state": "not_yet_reached", "index": 4},
        {"value": "C", "state": "not_yet_reached", "index": 5},
        {"value": "O", "state": "not_yet_reached", "index": 6},
        {"value": "D", "state": "not_yet_reached", "index": 7},
        {"value": "E", "state": "not_yet_reached", "index": 8},
        {"value": "B", "state": "not_yet_reached", "index": 9},
        {"value": "A", "state": "not_yet_reached", "index": 10},
        {"value": "N", "state": "not_yet_reached", "index": 11},
        {"value": "C", "state": "not_yet_reached", "index": 12}
      ],
      "pattern": "ABC",
      "patternFreq": {"A": 1, "B": 1, "C": 1},
      "windowFreq": {},
      "matches": 0,
      "requiredMatches": 3,
      "windowStart": 0,
      "windowEnd": 0,
      "currentLength": 0,
      "minWindow": "",
      "minLength": 999999
    },
    "steps": [
      {
        "stepId": 1,
        "description": "Initialize variables. Set windowStart = 0, matches = 0, windowFreq = {}, requiredMatches = 3, minLength = 999999, minWindow = \"\"",
        "expectedAction": "click_initialize",
        "uiState": {
          "stringElements": [
            {"value": "A", "state": "not_yet_reached", "index": 0},
            {"value": "D", "state": "not_yet_reached", "index": 1},
            {"value": "O", "state": "not_yet_reached", "index": 2},
            {"value": "B", "state": "not_yet_reached", "index": 3},
            {"value": "E", "state": "not_yet_reached", "index": 4},
            {"value": "C", "state": "not_yet_reached", "index": 5},
            {"value": "O", "state": "not_yet_reached", "index": 6},
            {"value": "D", "state": "not_yet_reached", "index": 7},
            {"value": "E", "state": "not_yet_reached", "index": 8},
            {"value": "B", "state": "not_yet_reached", "index": 9},
            {"value": "A", "state": "not_yet_reached", "index": 10},
            {"value": "N", "state": "not_yet_reached", "index": 11},
            {"value": "C", "state": "not_yet_reached", "index": 12}
          ],
          "pattern": "ABC",
          "patternFreq": {"A": 1, "B": 1, "C": 1},
          "windowFreq": {},
          "matches": 0,
          "requiredMatches": 3,
          "windowStart": 0,
          "windowEnd": 0,
          "currentLength": 0,
          "minWindow": "",
          "minLength": 999999,
          "highlightedElements": []
        },
        "jarvisMessage": "Welcome! Let's solve this minimum window problem. We need to find the smallest substring of s that contains all characters from t. We'll use a sliding window approach with character frequency tracking.",
        "codeHint": "// Initialize variables\nlet windowStart = 0;\nlet matches = 0;\nlet windowFreq = {};\nlet requiredMatches = Object.keys(patternFreq).length;\nlet minLength = 999999;\nlet minWindow = \"\";",
        "codeBotMessage": "Hey! I'm CodeBot. This is a classic minimum window problem. The key insight is to expand the window until we have all required characters, then contract from the left to find the minimum valid window!",
        "codeSnippet": "let windowStart = 0;        // Start of current window\nlet matches = 0;            // Characters that match pattern frequency\nlet windowFreq = {};        // Frequency map for current window\nlet requiredMatches = 3;    // We need 3 characters to match\nlet minLength = 999999;   // Track minimum window length\nlet minWindow = \"\";        // Store minimum window substring"
      },
      {
        "stepId": 2,
        "description": "Expand window to include first character 'A'. Update windowFreq['A'] = 1. Check if 'A' frequency matches pattern: yes! Update matches = 1",
        "expectedAction": "expand_window",
        "expectedElementIndex": 0,
        "uiState": {
          "stringElements": [
            {"value": "A", "state": "in_window", "index": 0},
            {"value": "D", "state": "not_yet_reached", "index": 1},
            {"value": "O", "state": "not_yet_reached", "index": 2},
            {"value": "B", "state": "not_yet_reached", "index": 3},
            {"value": "E", "state": "not_yet_reached", "index": 4},
            {"value": "C", "state": "not_yet_reached", "index": 5},
            {"value": "O", "state": "not_yet_reached", "index": 6},
            {"value": "D", "state": "not_yet_reached", "index": 7},
            {"value": "E", "state": "not_yet_reached", "index": 8},
            {"value": "B", "state": "not_yet_reached", "index": 9},
            {"value": "A", "state": "not_yet_reached", "index": 10},
            {"value": "N", "state": "not_yet_reached", "index": 11},
            {"value": "C", "state": "not_yet_reached", "index": 12}
          ],
          "pattern": "ABC",
          "patternFreq": {"A": 1, "B": 1, "C": 1},
          "windowFreq": {"A": 1},
          "matches": 1,
          "requiredMatches": 3,
          "windowStart": 0,
          "windowEnd": 0,
          "currentLength": 1,
          "minWindow": "",
          "minLength": 999999,
          "highlightedElements": [0]
        },
        "jarvisMessage": "Great! We've added 'A' to our window. Since 'A' appears exactly once in our pattern \"ABC\", and we have exactly one 'A' in our window, matches = 1. We need 2 more characters to have all required matches.",
        "codeHint": "// Add current character to window frequency\nwindowFreq[s[windowEnd]] = (windowFreq[s[windowEnd]] || 0) + 1;\n// Check if this character frequency now matches pattern requirement"
      },
      {
        "stepId": 3,
        "description": "Expand window to include 'D'. Update windowFreq['D'] = 1. Check if 'D' is in pattern: no, so no match update. Continue expanding",
        "expectedAction": "expand_window",
        "expectedElementIndex": 1,
        "uiState": {
          "stringElements": [
            {"value": "A", "state": "in_window", "index": 0},
            {"value": "D", "state": "in_window", "index": 1},
            {"value": "O", "state": "not_yet_reached", "index": 2},
            {"value": "B", "state": "not_yet_reached", "index": 3},
            {"value": "E", "state": "not_yet_reached", "index": 4},
            {"value": "C", "state": "not_yet_reached", "index": 5},
            {"value": "O", "state": "not_yet_reached", "index": 6},
            {"value": "D", "state": "not_yet_reached", "index": 7},
            {"value": "E", "state": "not_yet_reached", "index": 8},
            {"value": "B", "state": "not_yet_reached", "index": 9},
            {"value": "A", "state": "not_yet_reached", "index": 10},
            {"value": "N", "state": "not_yet_reached", "index": 11},
            {"value": "C", "state": "not_yet_reached", "index": 12}
          ],
          "pattern": "ABC",
          "patternFreq": {"A": 1, "B": 1, "C": 1},
          "windowFreq": {"A": 1, "D": 1},
          "matches": 1,
          "requiredMatches": 3,
          "windowStart": 0,
          "windowEnd": 1,
          "currentLength": 2,
          "minWindow": "",
          "minLength": 999999,
          "highlightedElements": [0, 1]
        },
        "jarvisMessage": "Now we have \"AD\" in our window. Since 'D' is not in our pattern \"ABC\", it doesn't contribute to our match count. We still have matches = 1. We need to continue expanding to find 'B' and 'C'.",
        "codeHint": "// Move window end pointer and update frequencies\nwindowEnd++;\n// Check if new character contributes to match count"
      },
      {
        "stepId": 4,
        "description": "Expand window to include 'O'. Update windowFreq['O'] = 1. Check if 'O' is in pattern: no, so no match update. Continue expanding",
        "expectedAction": "expand_window",
        "expectedElementIndex": 2,
        "uiState": {
          "stringElements": [
            {"value": "A", "state": "in_window", "index": 0},
            {"value": "D", "state": "in_window", "index": 1},
            {"value": "O", "state": "in_window", "index": 2},
            {"value": "B", "state": "not_yet_reached", "index": 3},
            {"value": "E", "state": "not_yet_reached", "index": 4},
            {"value": "C", "state": "not_yet_reached", "index": 5},
            {"value": "O", "state": "not_yet_reached", "index": 6},
            {"value": "D", "state": "not_yet_reached", "index": 7},
            {"value": "E", "state": "not_yet_reached", "index": 8},
            {"value": "B", "state": "not_yet_reached", "index": 9},
            {"value": "A", "state": "not_yet_reached", "index": 10},
            {"value": "N", "state": "not_yet_reached", "index": 11},
            {"value": "C", "state": "not_yet_reached", "index": 12}
          ],
          "pattern": "ABC",
          "patternFreq": {"A": 1, "B": 1, "C": 1},
          "windowFreq": {"A": 1, "D": 1, "O": 1},
          "matches": 1,
          "requiredMatches": 3,
          "windowStart": 0,
          "windowEnd": 2,
          "currentLength": 3,
          "minWindow": "",
          "minLength": 999999,
          "highlightedElements": [0, 1, 2]
        },
        "jarvisMessage": "We've added 'O' to get \"ADO\". Since 'O' is not in our pattern \"ABC\", matches remains 1. We still need to find 'B' and 'C' to have all required characters.",
        "codeHint": "// Continue expanding until we have all required characters\n// We need matches === requiredMatches to have a valid window"
      },
      {
        "stepId": 5,
        "description": "Expand window to include 'B'. Update windowFreq['B'] = 1. Check if 'B' frequency matches pattern: yes! Update matches = 2",
        "expectedAction": "expand_window",
        "expectedElementIndex": 3,
        "uiState": {
          "stringElements": [
            {"value": "A", "state": "in_window", "index": 0},
            {"value": "D", "state": "in_window", "index": 1},
            {"value": "O", "state": "in_window", "index": 2},
            {"value": "B", "state": "in_window", "index": 3},
            {"value": "E", "state": "not_yet_reached", "index": 4},
            {"value": "C", "state": "not_yet_reached", "index": 5},
            {"value": "O", "state": "not_yet_reached", "index": 6},
            {"value": "D", "state": "not_yet_reached", "index": 7},
            {"value": "E", "state": "not_yet_reached", "index": 8},
            {"value": "B", "state": "not_yet_reached", "index": 9},
            {"value": "A", "state": "not_yet_reached", "index": 10},
            {"value": "N", "state": "not_yet_reached", "index": 11},
            {"value": "C", "state": "not_yet_reached", "index": 12}
          ],
          "pattern": "ABC",
          "patternFreq": {"A": 1, "B": 1, "C": 1},
          "windowFreq": {"A": 1, "D": 1, "O": 1, "B": 1},
          "matches": 2,
          "requiredMatches": 3,
          "windowStart": 0,
          "windowEnd": 3,
          "currentLength": 4,
          "minWindow": "",
          "minLength": 999999,
          "highlightedElements": [0, 1, 2, 3]
        },
        "jarvisMessage": "Excellent! We've added 'B' to get \"ADOB\". Since 'B' appears exactly once in our pattern \"ABC\", matches = 2. We're getting closer! We just need to find 'C' to have all required characters.",
        "codeHint": "// We now have 2 out of 3 required characters\n// Continue expanding to find the last required character"
      },
      {
        "stepId": 6,
        "description": "Expand window to include 'E'. Update windowFreq['E'] = 1. Check if 'E' is in pattern: no, so no match update. Continue expanding",
        "expectedAction": "expand_window",
        "expectedElementIndex": 4,
        "uiState": {
          "stringElements": [
            {"value": "A", "state": "in_window", "index": 0},
            {"value": "D", "state": "in_window", "index": 1},
            {"value": "O", "state": "in_window", "index": 2},
            {"value": "B", "state": "in_window", "index": 3},
            {"value": "E", "state": "in_window", "index": 4},
            {"value": "C", "state": "not_yet_reached", "index": 5},
            {"value": "O", "state": "not_yet_reached", "index": 6},
            {"value": "D", "state": "not_yet_reached", "index": 7},
            {"value": "E", "state": "not_yet_reached", "index": 8},
            {"value": "B", "state": "not_yet_reached", "index": 9},
            {"value": "A", "state": "not_yet_reached", "index": 10},
            {"value": "N", "state": "not_yet_reached", "index": 11},
            {"value": "C", "state": "not_yet_reached", "index": 12}
          ],
          "pattern": "ABC",
          "patternFreq": {"A": 1, "B": 1, "C": 1},
          "windowFreq": {"A": 1, "D": 1, "O": 1, "B": 1, "E": 1},
          "matches": 2,
          "requiredMatches": 3,
          "windowStart": 0,
          "windowEnd": 4,
          "currentLength": 5,
          "minWindow": "",
          "minLength": 999999,
          "highlightedElements": [0, 1, 2, 3, 4]
        },
        "jarvisMessage": "We've added 'E' to get \"ADOBE\". Since 'E' is not in our pattern \"ABC\", matches remains 2. We still need to find 'C' to have all required characters.",
        "codeHint": "// Continue expanding until we find the last required character 'C'\n// The window is getting larger, but we need all characters first"
      },
      {
        "stepId": 7,
        "description": "Expand window to include 'C'. Update windowFreq['C'] = 1. Check if 'C' frequency matches pattern: yes! Update matches = 3. We have all required characters! Now contract from left to find minimum window",
        "expectedAction": "expand_window",
        "expectedElementIndex": 5,
        "uiState": {
          "stringElements": [
            {"value": "A", "state": "in_window", "index": 0},
            {"value": "D", "state": "in_window", "index": 1},
            {"value": "O", "state": "in_window", "index": 2},
            {"value": "B", "state": "in_window", "index": 3},
            {"value": "E", "state": "in_window", "index": 4},
            {"value": "C", "state": "in_window", "index": 5},
            {"value": "O", "state": "not_yet_reached", "index": 6},
            {"value": "D", "state": "not_yet_reached", "index": 7},
            {"value": "E", "state": "not_yet_reached", "index": 8},
            {"value": "B", "state": "not_yet_reached", "index": 9},
            {"value": "A", "state": "not_yet_reached", "index": 10},
            {"value": "N", "state": "not_yet_reached", "index": 11},
            {"value": "C", "state": "not_yet_reached", "index": 12}
          ],
          "pattern": "ABC",
          "patternFreq": {"A": 1, "B": 1, "C": 1},
          "windowFreq": {"A": 1, "D": 1, "O": 1, "B": 1, "E": 1, "C": 1},
          "matches": 3,
          "requiredMatches": 3,
          "windowStart": 0,
          "windowEnd": 5,
          "currentLength": 6,
          "minWindow": "",
          "minLength": 999999,
          "highlightedElements": [0, 1, 2, 3, 4, 5]
        },
        "jarvisMessage": "ðŸŽ‰ Fantastic! We've found all required characters! The window \"ADOBEC\" has matches = 3. Now we have a valid window, but it might not be the minimum. We need to contract from the left to find the smallest valid window.",
        "codeHint": "// We now have all required characters (matches === requiredMatches)\n// Contract from left to find the minimum valid window\n// Remove characters that don't affect our match count"
      },
      {
        "stepId": 8,
        "description": "Contract window by removing leftmost 'A'. Update windowFreq['A'] = 0. Since 'A' was contributing to matches, decrement matches = 2. Window becomes invalid, so we can't remove 'A'. Restore 'A' and update minWindow = \"ADOBEC\"",
        "expectedAction": "contract_window",
        "expectedElementIndex": 0,
        "uiState": {
          "stringElements": [
            {"value": "A", "state": "in_window", "index": 0},
            {"value": "D", "state": "in_window", "index": 1},
            {"value": "O", "state": "in_window", "index": 2},
            {"value": "B", "state": "in_window", "index": 3},
            {"value": "E", "state": "in_window", "index": 4},
            {"value": "C", "state": "in_window", "index": 5},
            {"value": "O", "state": "not_yet_reached", "index": 6},
            {"value": "D", "state": "not_yet_reached", "index": 7},
            {"value": "E", "state": "not_yet_reached", "index": 8},
            {"value": "B", "state": "not_yet_reached", "index": 9},
            {"value": "A", "state": "not_yet_reached", "index": 10},
            {"value": "N", "state": "not_yet_reached", "index": 11},
            {"value": "C", "state": "not_yet_reached", "index": 12}
          ],
          "pattern": "ABC",
          "patternFreq": {"A": 1, "B": 1, "C": 1},
          "windowFreq": {"A": 1, "D": 1, "O": 1, "B": 1, "E": 1, "C": 1},
          "matches": 3,
          "requiredMatches": 3,
          "windowStart": 0,
          "windowEnd": 5,
          "currentLength": 6,
          "minWindow": "ADOBEC",
          "minLength": 6,
          "highlightedElements": [0, 1, 2, 3, 4, 5]
        },
        "jarvisMessage": "We tried to remove 'A', but that would make our window invalid (matches < 3). So we keep 'A' and update our minimum window. Current minWindow = \"ADOBEC\" with length 6. We continue expanding to find potentially smaller windows.",
        "codeHint": "// We can't remove 'A' as it would make window invalid\n// Update minimum window if current window is smaller\nif (currentLength < minLength) {\n  minLength = currentLength;\n  minWindow = s.substring(windowStart, windowEnd + 1);\n}"
      },
      {
        "stepId": 9,
        "description": "Continue expanding. Add 'O'. Update windowFreq['O'] = 2. Since 'O' not in pattern, no change to matches. Window still valid. Continue expanding",
        "expectedAction": "expand_window",
        "expectedElementIndex": 6,
        "uiState": {
          "stringElements": [
            {"value": "A", "state": "in_window", "index": 0},
            {"value": "D", "state": "in_window", "index": 1},
            {"value": "O", "state": "in_window", "index": 2},
            {"value": "B", "state": "in_window", "index": 3},
            {"value": "E", "state": "in_window", "index": 4},
            {"value": "C", "state": "in_window", "index": 5},
            {"value": "O", "state": "in_window", "index": 6},
            {"value": "D", "state": "not_yet_reached", "index": 7},
            {"value": "E", "state": "not_yet_reached", "index": 8},
            {"value": "B", "state": "not_yet_reached", "index": 9},
            {"value": "A", "state": "not_yet_reached", "index": 10},
            {"value": "N", "state": "not_yet_reached", "index": 11},
            {"value": "C", "state": "not_yet_reached", "index": 12}
          ],
          "pattern": "ABC",
          "patternFreq": {"A": 1, "B": 1, "C": 1},
          "windowFreq": {"A": 1, "D": 1, "O": 2, "B": 1, "E": 1, "C": 1},
          "matches": 3,
          "requiredMatches": 3,
          "windowStart": 0,
          "windowEnd": 6,
          "currentLength": 7,
          "minWindow": "ADOBEC",
          "minLength": 6,
          "highlightedElements": [0, 1, 2, 3, 4, 5, 6]
        },
        "jarvisMessage": "We've added 'O' to get \"ADOBECO\". Since 'O' is not in our pattern \"ABC\", matches remains 3. The window is still valid, but it's getting larger. We need to continue expanding to find potentially smaller windows.",
        "codeHint": "// Continue expanding to find potentially smaller windows\n// The current window is valid but might not be optimal"
      },
      {
        "stepId": 10,
        "description": "Continue expanding through remaining characters. Eventually find smaller window \"BANC\" at indices 9-12. Update minWindow = \"BANC\", minLength = 4",
        "expectedAction": "expand_window",
        "expectedElementIndex": 7,
        "uiState": {
          "stringElements": [
            {"value": "A", "state": "out_of_window_past", "index": 0},
            {"value": "D", "state": "out_of_window_past", "index": 1},
            {"value": "O", "state": "out_of_window_past", "index": 2},
            {"value": "B", "state": "out_of_window_past", "index": 3},
            {"value": "E", "state": "out_of_window_past", "index": 4},
            {"value": "C", "state": "out_of_window_past", "index": 5},
            {"value": "O", "state": "out_of_window_past", "index": 6},
            {"value": "D", "state": "out_of_window_past", "index": 7},
            {"value": "E", "state": "out_of_window_past", "index": 8},
            {"value": "B", "state": "in_window", "index": 9},
            {"value": "A", "state": "in_window", "index": 10},
            {"value": "N", "state": "in_window", "index": 11},
            {"value": "C", "state": "in_window", "index": 12}
          ],
          "pattern": "ABC",
          "patternFreq": {"A": 1, "B": 1, "C": 1},
          "windowFreq": {"B": 1, "A": 1, "N": 1, "C": 1},
          "matches": 3,
          "requiredMatches": 3,
          "windowStart": 9,
          "windowEnd": 12,
          "currentLength": 4,
          "minWindow": "BANC",
          "minLength": 4,
          "highlightedElements": [9, 10, 11, 12]
        },
        "jarvisMessage": "ðŸŽ‰ Excellent! We've found a smaller valid window! \"BANC\" at indices 9-12 has length 4 and contains all required characters. This is smaller than our previous minimum of 6, so we update minWindow = \"BANC\" and minLength = 4.",
        "codeHint": "// Found a smaller valid window!\n// Update minimum window if current window is smaller\nif (currentLength < minLength) {\n  minLength = currentLength;\n  minWindow = s.substring(windowStart, windowEnd + 1);\n}"
      },
      {
        "stepId": 11,
        "description": "Algorithm completed! The minimum window containing all characters from \"ABC\" is \"BANC\" with length 4.",
        "expectedAction": "complete_algorithm",
        "expectedElementIndex": 12,
        "uiState": {
          "stringElements": [
            {"value": "A", "state": "out_of_window_past", "index": 0},
            {"value": "D", "state": "out_of_window_past", "index": 1},
            {"value": "O", "state": "out_of_window_past", "index": 2},
            {"value": "B", "state": "out_of_window_past", "index": 3},
            {"value": "E", "state": "out_of_window_past", "index": 4},
            {"value": "C", "state": "out_of_window_past", "index": 5},
            {"value": "O", "state": "out_of_window_past", "index": 6},
            {"value": "D", "state": "out_of_window_past", "index": 7},
            {"value": "E", "state": "out_of_window_past", "index": 8},
            {"value": "B", "state": "in_window", "index": 9},
            {"value": "A", "state": "in_window", "index": 10},
            {"value": "N", "state": "in_window", "index": 11},
            {"value": "C", "state": "in_window", "index": 12}
          ],
          "pattern": "ABC",
          "patternFreq": {"A": 1, "B": 1, "C": 1},
          "windowFreq": {"B": 1, "A": 1, "N": 1, "C": 1},
          "matches": 3,
          "requiredMatches": 3,
          "windowStart": 9,
          "windowEnd": 12,
          "currentLength": 4,
          "minWindow": "BANC",
          "minLength": 4,
          "highlightedElements": [9, 10, 11, 12]
        },
        "jarvisMessage": "ðŸŽ‰ Congratulations! You've successfully completed the minimum window algorithm. The smallest window containing all characters from \"ABC\" is \"BANC\" with length 4.",
        "codeHint": "// Return the final result\nreturn minWindow; // Returns \"BANC\"",
        "codeBotMessage": "Fantastic! You've mastered this advanced sliding window problem. The key insight was expanding until we have all required characters, then contracting to find the minimum valid window. This gives us O(n) time complexity!",
        "codeSnippet": "// Algorithm completed!\n// Minimum window containing all characters: \"BANC\"\n// Final result: minWindow = \"BANC\"\nreturn minWindow; // Returns \"BANC\""
      }
    ],
    "jarvisConfig": {
      "personality": "encouraging",
      "hintLevels": ["subtle", "helpful", "explicit"],
      "motivationalMessages": [
        "Great thinking! You're understanding the minimum window concept.",
        "That's exactly right! You're seeing how to find optimal windows.",
        "Excellent intuition! You're mastering the contraction logic.",
        "You've got this! Each step brings you closer to mastering advanced sliding window."
      ]
    }
  },
  "solution": {
    "bruteForce": {
      "idea": "Generate all possible substrings and check if each contains all characters from t.",
      "timeComplexity": "O(nÂ³)",
      "spaceComplexity": "O(1)",
      "walkthrough": [
        "Generate all possible substrings of s.",
        "For each substring, check if it contains all characters from t.",
        "Track the minimum length substring that satisfies the condition.",
        "Return the minimum window substring."
      ]
    },
    "optimal": {
      "idea": "Use sliding window with character frequency tracking. Expand until all characters are found, then contract to find the minimum valid window.",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "walkthrough": [
        "Create frequency map for pattern t.",
        "Initialize sliding window and expand until all characters are found.",
        "Track when we have all required characters (matches === requiredMatches).",
        "Contract window from left to find minimum valid window.",
        "Continue expanding and contracting to find potentially smaller windows.",
        "Return the minimum window substring found."
      ]
    }
  },
  "code": {
    "javascript": "function minWindow(s, t) {\n    if (s.length < t.length) return \"\";\n    \n    const patternFreq = {};\n    const windowFreq = {};\n    \n    // Create frequency map for pattern\n    for (let char of t) {\n        patternFreq[char] = (patternFreq[char] || 0) + 1;\n    }\n    \n    let windowStart = 0;\n    let matches = 0;\n    const requiredMatches = Object.keys(patternFreq).length;\n    let minLength = 999999;\n    let minWindow = \"\";\n    \n    for (let windowEnd = 0; windowEnd < s.length; windowEnd++) {\n        const rightChar = s[windowEnd];\n        \n        // Add right character to window\n        if (patternFreq[rightChar]) {\n            windowFreq[rightChar] = (windowFreq[rightChar] || 0) + 1;\n            if (windowFreq[rightChar] === patternFreq[rightChar]) {\n                matches++;\n            }\n        }\n        \n        // Contract window from left when we have all characters\n        while (matches === requiredMatches) {\n            const currentLength = windowEnd - windowStart + 1;\n            \n            // Update minimum window if current is smaller\n            if (currentLength < minLength) {\n                minLength = currentLength;\n                minWindow = s.substring(windowStart, windowEnd + 1);\n            }\n            \n            const leftChar = s[windowStart];\n            if (patternFreq[leftChar]) {\n                if (windowFreq[leftChar] === patternFreq[leftChar]) {\n                    matches--;\n                }\n                windowFreq[leftChar]--;\n            }\n            windowStart++;\n        }\n    }\n    \n    return minWindow;\n}"
  }
}
