{
  "problemId": "p1",
  "title": "Maximum Sum Subarray of Size K",
  "description": "Given an array of positive numbers and a positive number 'k,' find the maximum sum of any contiguous subarray of size 'k'.",
  "aim": "The goal is to introduce the sliding window technique and show how it improves over brute force for fixed-size subarray problems.",
  "moduleId": "slidingWindow",
  "submoduleId": "sw_fixed",
  "difficulty": "Easy",
  "tags": ["Array", "Sliding Window", "Fixed Size"],
  "examples": [
    {
      "input": "arr = [2, 1, 5, 1, 3, 2], k = 3",
      "output": "9",
      "explanation": "Subarray [5, 1, 3] has the maximum sum of 9."
    },
    {
      "input": "arr = [2, 3, 4, 1, 5], k = 2",
      "output": "7",
      "explanation": "Subarray [3, 4] has the maximum sum of 7."
    }
  ],
  "playground": {
    "initialState": {
      "array": [2, 1, 5, 1, 3, 2],
      "k": 3,
      "windowSum": 0,
      "maxSum": 0,
      "windowStart": 0,
      "windowEnd": 0
    },
    "steps": [
      {
        "stepId": 1,
        "description": "Initialize variables. Set windowSum = 0, maxSum = 0, windowStart = 0",
        "expectedAction": "click_initialize",
        "uiState": {
          "arrayElements": [
            {"value": 2, "state": "not_yet_reached", "index": 0},
            {"value": 1, "state": "not_yet_reached", "index": 1},
            {"value": 5, "state": "not_yet_reached", "index": 2},
            {"value": 1, "state": "not_yet_reached", "index": 3},
            {"value": 3, "state": "not_yet_reached", "index": 4},
            {"value": 2, "state": "not_yet_reached", "index": 5}
          ],
          "windowStart": null,
          "windowEnd": null,
          "windowSum": 0,
          "maxSum": 0,
          "highlightedElements": []
        },
        "jarvisMessage": "Welcome! Let's start by initializing our variables. Click the 'Initialize' button to set up windowSum = 0, maxSum = 0, and windowStart = 0.",
        "codeHint": "// Initialize variables\nlet windowSum = 0;\nlet maxSum = 0;\nlet windowStart = 0;",
        "codeBotMessage": "Hey there! I'm CodeBot. When you click Initialize, this code runs: we create three variables to track our sliding window algorithm. Think of it as setting up the foundation before building a house!",
        "codeSnippet": "let windowSum = 0;    // Track current window sum\nlet maxSum = 0;      // Track maximum sum found\nlet windowStart = 0; // Track window start position"
      },
      {
        "stepId": 2,
        "description": "Add first element to window. windowSum += arr[0] = 2",
        "expectedAction": "add_element_to_window",
        "expectedElementIndex": 0,
        "uiState": {
          "arrayElements": [
            {"value": 2, "state": "in_window", "index": 0},
            {"value": 1, "state": "not_yet_reached", "index": 1},
            {"value": 5, "state": "not_yet_reached", "index": 2},
            {"value": 1, "state": "not_yet_reached", "index": 3},
            {"value": 3, "state": "not_yet_reached", "index": 4},
            {"value": 2, "state": "not_yet_reached", "index": 5}
          ],
          "windowStart": 0,
          "windowEnd": 0,
          "windowSum": 2,
          "maxSum": 0,
          "highlightedElements": [0]
        },
        "jarvisMessage": "Great! We've added the first element (2) to our window. Now windowSum = 2. Notice how we're building our window step by step.",
        "codeHint": "// Add current element to window\nwindowSum += arr[windowEnd];"
      },
      {
        "stepId": 3,
        "description": "Add second element to window. windowSum += arr[1] = 1, total = 3",
        "expectedAction": "add_element_to_window",
        "expectedElementIndex": 1,
        "uiState": {
          "arrayElements": [
            {"value": 2, "state": "in_window", "index": 0},
            {"value": 1, "state": "in_window", "index": 1},
            {"value": 5, "state": "not_yet_reached", "index": 2},
            {"value": 1, "state": "not_yet_reached", "index": 3},
            {"value": 3, "state": "not_yet_reached", "index": 4},
            {"value": 2, "state": "not_yet_reached", "index": 5}
          ],
          "windowStart": 0,
          "windowEnd": 1,
          "windowSum": 3,
          "maxSum": 0,
          "highlightedElements": [0, 1]
        },
        "jarvisMessage": "Excellent! Now we have 2 elements in our window: [2, 1]. Our windowSum = 3. We're getting closer to our target window size of 3!",
        "codeHint": "// Move window end pointer\nwindowEnd++;\nwindowSum += arr[windowEnd];"
      },
      {
        "stepId": 4,
        "description": "Add third element to complete first window. windowSum += arr[2] = 5, total = 8. Update maxSum = 8",
        "expectedAction": "complete_first_window",
        "expectedElementIndex": 2,
        "uiState": {
          "arrayElements": [
            {"value": 2, "state": "in_window", "index": 0},
            {"value": 1, "state": "in_window", "index": 1},
            {"value": 5, "state": "in_window", "index": 2},
            {"value": 1, "state": "not_yet_reached", "index": 3},
            {"value": 3, "state": "not_yet_reached", "index": 4},
            {"value": 2, "state": "not_yet_reached", "index": 5}
          ],
          "windowStart": 0,
          "windowEnd": 2,
          "windowSum": 8,
          "maxSum": 8,
          "highlightedElements": [0, 1, 2]
        },
        "jarvisMessage": "Perfect! We now have our first complete window of size 3: [2, 1, 5] with sum = 8. This becomes our first maxSum. Now the magic happens - we'll start sliding!",
        "codeHint": "// First complete window - update maxSum\nif (windowEnd >= k - 1) {\n  maxSum = Math.max(maxSum, windowSum);\n}",
        "codeBotMessage": "Great job! Now the code checks if we have a complete window (when windowEnd >= k-1). Since we do, it updates maxSum to 8. This is the first time we've found a valid subarray sum!",
        "codeSnippet": "if (windowEnd >= k - 1) {\n  maxSum = Math.max(maxSum, windowSum);\n  // maxSum becomes 8 (first valid window)\n}"
      },
      {
        "stepId": 5,
        "description": "Slide window: remove arr[0] = 2, add arr[3] = 1. windowSum = 8 - 2 + 1 = 7",
        "expectedAction": "slide_window",
        "expectedElementIndex": 3,
        "expectedRemoveIndex": 0,
        "expectedAddIndex": 3,
        "uiState": {
          "arrayElements": [
            {"value": 2, "state": "out_of_window_past", "index": 0},
            {"value": 1, "state": "in_window", "index": 1},
            {"value": 5, "state": "in_window", "index": 2},
            {"value": 1, "state": "in_window", "index": 3},
            {"value": 3, "state": "not_yet_reached", "index": 4},
            {"value": 2, "state": "not_yet_reached", "index": 5}
          ],
          "windowStart": 1,
          "windowEnd": 3,
          "windowSum": 7,
          "maxSum": 8,
          "highlightedElements": [1, 2, 3]
        },
        "jarvisMessage": "This is the key insight of sliding window! Instead of recalculating the sum, we just subtract the leftmost element (2) and add the new rightmost element (1). New windowSum = 7. Since 7 < 8, maxSum stays 8.",
        "codeHint": "// Slide the window\nwindowSum -= arr[windowStart];\nwindowStart++;\nwindowSum += arr[windowEnd];",
        "codeBotMessage": "This is where the magic happens! The code efficiently slides the window by subtracting the leftmost element and adding the new rightmost element. No need to recalculate the entire sum - that's why it's O(n) instead of O(n*k)!",
        "codeSnippet": "windowSum -= arr[windowStart]; // Remove left element (2)\nwindowStart++;                  // Move start pointer\nwindowSum += arr[windowEnd];   // Add new element (1)\n// Result: 8 - 2 + 1 = 7"
      },
      {
        "stepId": 6,
        "description": "Slide window: remove arr[1] = 1, add arr[4] = 3. windowSum = 7 - 1 + 3 = 9. Update maxSum = 9",
        "expectedAction": "slide_window",
        "expectedElementIndex": 4,
        "expectedRemoveIndex": 1,
        "expectedAddIndex": 4,
        "uiState": {
          "arrayElements": [
            {"value": 2, "state": "out_of_window_past", "index": 0},
            {"value": 1, "state": "out_of_window_past", "index": 1},
            {"value": 5, "state": "in_window", "index": 2},
            {"value": 1, "state": "in_window", "index": 3},
            {"value": 3, "state": "in_window", "index": 4},
            {"value": 2, "state": "not_yet_reached", "index": 5}
          ],
          "windowStart": 2,
          "windowEnd": 4,
          "windowSum": 9,
          "maxSum": 9,
          "highlightedElements": [2, 3, 4]
        },
        "jarvisMessage": "Fantastic! Our new window [5, 1, 3] has sum = 9, which is greater than our previous maxSum of 8. So we update maxSum = 9. This is why sliding window is so powerful - we're finding the best solution efficiently!",
        "codeHint": "// Update maxSum if current window is better\nmaxSum = Math.max(maxSum, windowSum);"
      },
      {
        "stepId": 7,
        "description": "Final slide: remove arr[2] = 5, add arr[5] = 2. windowSum = 9 - 5 + 2 = 6. Final maxSum = 9",
        "expectedAction": "slide_window",
        "expectedElementIndex": 5,
        "expectedRemoveIndex": 2,
        "expectedAddIndex": 5,
        "uiState": {
          "arrayElements": [
            {"value": 2, "state": "out_of_window_past", "index": 0},
            {"value": 1, "state": "out_of_window_past", "index": 1},
            {"value": 5, "state": "out_of_window_past", "index": 2},
            {"value": 1, "state": "in_window", "index": 3},
            {"value": 3, "state": "in_window", "index": 4},
            {"value": 2, "state": "in_window", "index": 5}
          ],
          "windowStart": 3,
          "windowEnd": 5,
          "windowSum": 6,
          "maxSum": 9,
          "highlightedElements": [3, 4, 5]
        },
        "jarvisMessage": "Perfect! Our final window [1, 3, 2] has sum = 6. Since 6 < 9, our maxSum remains 9. We've successfully found the maximum sum subarray of size 3!",
        "codeHint": "// Final result\nreturn maxSum; // Returns 9"
      },
      {
        "stepId": 8,
        "description": "Algorithm completed!",
        "expectedAction": "complete_algorithm",
        "expectedElementIndex": 5,
        "uiState": {
          "arrayElements": [
            {"value": 2, "state": "out_of_window_past", "index": 0},
            {"value": 1, "state": "out_of_window_past", "index": 1},
            {"value": 5, "state": "out_of_window_past", "index": 2},
            {"value": 1, "state": "in_window", "index": 3},
            {"value": 3, "state": "in_window", "index": 4},
            {"value": 2, "state": "in_window", "index": 5}
          ],
          "windowStart": 3,
          "windowEnd": 5,
          "windowSum": 6,
          "maxSum": 9,
          "highlightedElements": [3, 4, 5]
        },
        "jarvisMessage": "ðŸŽ‰ Congratulations! You've successfully completed the sliding window algorithm walkthrough. You now understand how the algorithm efficiently finds the maximum sum subarray!",
        "codeHint": "// Algorithm completed successfully\n// Final result: maxSum = 9",
        "codeBotMessage": "Fantastic! You've completed the entire sliding window algorithm. The code has successfully found the maximum sum subarray of size 3, which is [5, 1, 3] with sum = 9. You now understand both the intuition and implementation!",
        "codeSnippet": "// Algorithm completed!\n// Final result: maxSum = 9\n// Subarray [5, 1, 3] has maximum sum\nreturn maxSum; // Returns 9"
      }
    ],
    "jarvisConfig": {
      "personality": "encouraging",
      "hintLevels": ["subtle", "helpful", "explicit"],
      "motivationalMessages": [
        "Great thinking! You're building the foundation step by step.",
        "That's exactly right! You're seeing the pattern now.",
        "Excellent intuition! You're understanding the sliding window concept.",
        "You've got this! Each step brings you closer to mastery."
      ]
    }
  },
  "solution": {
    "bruteForce": {
      "idea": "Check every subarray of size k, compute its sum, and track the maximum.",
      "timeComplexity": "O(n*k)",
      "spaceComplexity": "O(1)",
      "walkthrough": [
        "Initialize maxSum = 0.",
        "Iterate i from 0 to n - k.",
        "For each i, compute windowSum by adding arr[i] to arr[i+k-1].",
        "Update maxSum if windowSum > maxSum.",
        "Return maxSum at the end."
      ]
    },
    "optimal": {
      "idea": "Use a sliding window to maintain the sum of the last k elements and update in O(1) time as the window slides.",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "walkthrough": [
        "Initialize maxSum = 0 and windowSum = 0.",
        "Build the first window of size k by summing the first k elements.",
        "Set maxSum = windowSum.",
        "Slide the window forward by adding arr[end] and subtracting arr[start].",
        "At each step, update maxSum if windowSum is larger.",
        "Return maxSum after traversing the array."
      ]
    }
  },
  "code": {
    "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int findMaxSumSubArray(int k, const vector<int>& arr) {\n        int maxSum = 0;\n        int windowSum;\n        for (int i = 0; i <= arr.size() - k; i++) {\n            windowSum = 0;\n            for (int j = i; j < i + k; j++) {\n                windowSum += arr[j];\n            }\n            maxSum = max(maxSum, windowSum);\n        }\n        return maxSum;\n    }\n};\n\nint main() {\n    Solution sol;\n    cout << sol.findMaxSumSubArray(3, {2, 1, 5, 1, 3, 2}) << endl;\n    cout << sol.findMaxSumSubArray(2, {2, 3, 4, 1, 5}) << endl;\n}"
  }
}